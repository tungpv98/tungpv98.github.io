<?xml version="1.0" encoding="utf-8"?>






<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Tung&#39;s Blog</title>
        <link>https://tungpv98.github.io/</link>
        <description></description>
        <generator>Hugo 0.68.3 https://gohugo.io/</generator>
        
            <language>en</language>
        
        
            <managingEditor>tungpv98@gmail.com (gnuT_98)</managingEditor>
        
        
            <webMaster>tungpv98@gmail.com (gnuT_98)</webMaster>
        
        
        <lastBuildDate>Thu, 18 Feb 2021 16:09:52 +0700</lastBuildDate>
        
            <atom:link rel="self" type="application/rss+xml" href="https://tungpv98.github.io/rss.xml" />
        
        
            
                <item>
                    <title>GMO Payment Gateway Plus (Link type Connection)</title>
                    <link>https://tungpv98.github.io/posts/gmo-payment-gateway-plus-link-type-connection/</link>
                    <guid isPermaLink="true">https://tungpv98.github.io/posts/gmo-payment-gateway-plus-link-type-connection/</guid>
                    <pubDate>Fri, 22 Jan 2021 08:40:36 +0700</pubDate>
                    <description><![CDATA[<h2 id="1-gmo-payment-gateway-là-gì">1. GMO payment Gateway là gì?</h2>
<p>GMO payment gateway là một cổng thanh toán điện tử của Nhật Bản. Cung cấp các dịch vụ xử lý thanh toán cho các giao dịch thương mại trực tuyến và thẻ tín dụng. Nó cung cấp nhiều phương thức thanh toán khác nhau cho các doanh nghiệp thông qua các cổng thanh toán như thẻ tín dụng, cửa hàng tiện lợi, tiền điện tử, Paypal...</p>
<p>GMO PG cung cấp 3 loại hình kết nối cho việc triển khai hệ thống thanh toán:</p>
<ol>
<li>Protocol type: GMO sẽ cung cấp các đầu API cho việc quản lý thành viên, thẻ và thanh toán. Các thông tin như SiteID, SitePass, ShopId, ShopPass sẽ được sử dụng để gọi được các API này.</li>
<li>Module type: GMO cung cấp cho chúng ta một module(Java, PHP) để xử lý thanh toán có thể tích hợp vào trong máy chủ của website.</li>
<li>Link type: Việc thanh toán sẽ được chuyển hướng đến site của GMO, khách hàng sẽ tiến hành nhập thông tin thanh toán bên site của GMO mà không phải nhập thông tin trên website của shop. Việc này đảm bảo an toàn hơn. Giao diện của màn hình thanh toán có thể tùy biến tùy vào config của Shop trên trang quản lý shop của GMO.</li>
</ol>
<p>Để tìm hiểu thêm về GMO, đăng ký môi trường test và tìm hiểu về loại hình kết nối <strong>Protocol type</strong>  thì mọi người có thể đọc thêm bài viết : <a href="https://viblo.asia/p/tim-hieu-ve-cong-thanh-toan-gmo-3P0lPvMpKox">Tìm hiểu về cổng thanh toán GMO</a> của tác giả <a href="https://viblo.asia/u/trantrinh1102">Tran Cong Trinh</a>.</p>
<blockquote>
<p>Còn ở bài viết này, mình sẽ giới thiệu loại hình kết nối <strong>Link type</strong>, được nhiều hệ thống ưu tiên sử dụng vì tính ưu việt và đảm bảo an toàn hơn so với loại <strong>Protocol type</strong>.</p>
</blockquote>
<p>Gmo payment gateway cung cấp 2 chức năng chính đó là:</p>
<ul>
<li>chức năng chỉnh sửa thẻ(card).</li>
<li>chức năng thanh toán.</li>
</ul>
<h2 id="2-chức-năng-chỉnh-sửa-thẻ">2. Chức năng chỉnh sửa thẻ.</h2>
<p><img src="https://images.viblo.asia/52a0dcee-6a83-4950-b65b-c51eece86bd7.png" alt="">
Mô tả luồng hoạt động :</p>
<ol>
<li>Người dùng yêu cầu chỉnh sửa thẻ( trên website của shop).</li>
<li>Website (phía shop) điều hướng đến Url chỉnh sửa thẻ của GMO.</li>
<li>Người dùng nhập thông tin thẻ và nhấn cập nhật (trên site GMO).</li>
<li>GMO thông báo về website của shop về việc cập nhật thẻ thành công.</li>
<li>GMO hiện thị thông báo cập nhật thẻ thành công cho người dùng.</li>
<li>Người dùng nhấn nút quay về trên site GMO, và được chuyển hướng về website của shop.</li>
</ol>
<p>Vậy trong luồng hoạt động này, thì để điều hướng được người dùng đến site của GMO và nhập thông tin chỉnh sửa thẻ, thì chúng ta cần lấy được URL chỉnh sửa thẻ của GMO và nhúng vào trong trang web của chúng ta. Để mỗi lần người dùng yêu cầu chỉnh sửa thẻ thì chúng ta chỉ cần redirect đến cái Url đấy là được. Còn lại các công việc khác như nhận thông tin thẻ hay lưu lại thì GMO sẽ xử lý hoàn toàn.</p>
<p>Để tạo được URL này thì có 2 cách :</p>
<ol>
<li>Chúng ta có thể tự tạo ra URL này dựa vào quy tắc mà GMO cung cấp.</li>
<li>Chúng ta gọi API của GMO để GMO trả về cho chúng ta URL.</li>
</ol>
<h3 id="21-tạo-url-chỉnh-sửa-thẻ-theo-định-dạng-mà-gmo-quy-định">2.1 Tạo URL chỉnh sửa thẻ theo định dạng mà GMO quy định.</h3>
<p>Format của URL chỉnh sửa thẻ :
<img src="https://images.viblo.asia/4089f3f5-cc4e-4e98-a98c-a35fba959d4f.png" alt=""></p>
<ol>
<li>Giao thức https (http không khả dụng)</li>
<li>Domain GMO: Môi trường production: link.mul-pay.jp. Môi trường test: stg.link.mul-pay.jp</li>
<li>Version.</li>
<li>Tên của loại thanh toán Gmo plus.</li>
<li>ID cửa hàng. (ID cửa hàng của cửa hàng thành viên).</li>
<li>Loại chức năng. Chỉ định &quot;member&quot; cho biết chức năng chỉnh sửa thẻ.</li>
<li>Bộ tham số được mã hóa base64 + mã băm của nó. ( chi tiết mình sẽ mô tả sau).</li>
</ol>
<p>Các bước để tạo bộ tham số mã hóa base64 và mã băm (7).
<img src="https://images.viblo.asia/d13a54aa-bd12-46c7-b2c8-2d45e9d81d8d.png" alt="">
Đại loại là sẽ cần tạo ra dữ liệu String từ Json, bao gồm các thông số như trên hình.</p>
<p>Sau đó dùng hàm Base64Encode để mã hóa dữ liệu trên.</p>
<p>Nối đoạn dữ liệu sau khi encode bằng base64 với ShopPass và băm với hàm băm sha256.
Cái được chú thích (7) trên hình là kết quả  nối chuỗi của base64Encode và hash được phân cách bởi dấu chấm (&quot;.&quot;).</p>
<p>Code bằng Java như sau:
{@embed: <a href="https://gist.github.com/tungpv-0974/a523fe679aab330a5b0029252e584dce%7D">https://gist.github.com/tungpv-0974/a523fe679aab330a5b0029252e584dce}</a></p>
<p>Các thông tin như shopId, shopPass thì lúc đăng ký GMO sẽ cung cấp cho chúng ta, chi tiết thì đọc bài viết mình có đính kèm ở bên trên nhé!
Còn bộ tham số như configid, member,... thì các bạn đọc chi tiết ở <strong>mục 19.5.1 trang 142</strong> <a href="https://drive.google.com/file/d/1gcpTEoKt7-_QWgZPqWI4f30RdkKxCr28/view?usp=sharing">tài liệu này</a> nhé.</p>
<h3 id="22--api-get-url-do-gmo-cung-cấp">2.2  API get URL do GMO cung cấp.</h3>
<p>GMO sẽ cung cấp cho chúng ta đầu API sau để get URL edit member :  <strong>[POST]https://[gmo-url]/payment/GetLinkplusUrlMember.json</strong></p>
<p>[gmo-url] là thông tin được gửi về trong email lúc chúng ta đăng ký với GMO, xem thêm bài viết  <a href="https://viblo.asia/p/tim-hieu-ve-cong-thanh-toan-gmo-3P0lPvMpKox">Tìm hiểu về cổng thanh toán GMO</a> của tác giả <a href="https://viblo.asia/u/trantrinh1102">Tran Cong Trinh</a>.</p>
<p>example: <a href="https://kt01.mul-pay.jp/payment/GetLinkplusUrlMember.json">https://kt01.mul-pay.jp/payment/GetLinkplusUrlMember.json</a></p>
<p>Khi chúng ta gọi API này thành công, sẽ nhận được một URL có format như sau:
<img src="https://images.viblo.asia/bbb4ba9e-968c-4945-93be-41bdf8785e26.png" alt=""></p>
<p>Chỉ khác với format URL mà chúng ta tự tạo ở phần 2.1 là nó được chỉ định version là v2. và (7) là một API key chứ không còn là bộ tham số được mã hóa base64 + hash nữa.
Mình có một đoạn CURL example để call API này như sau:</p>
<pre><code>curl --location --request POST 'https://kt01.mul-pay.jp/payment/GetLinkplusUrlMember.json' \
--header 'Content-Type: application/json' \
--data-raw '{
    &quot;configid&quot;: &quot;001&quot;,
    &quot;geturlparam&quot;:{
        &quot;ShopID&quot;: &quot;tshop00001111&quot;,
        &quot;ShopPass&quot;: &quot;shopPass&quot;
    },
    &quot;member&quot;: {
        &quot;MemberID&quot;: &quot;sample&quot;,
        &quot;MemberName&quot;: &quot;Phan Van Tung&quot;,
        &quot;Cardeditno&quot;: &quot;CardEditNo001&quot;
    }
}'
</code></pre><p>Các tham số chi tiết các bạn đọc ở mục <strong>19.5.1 trang 142</strong> <a href="https://drive.google.com/file/d/1gcpTEoKt7-_QWgZPqWI4f30RdkKxCr28/view?usp=sharing">tài liệu này</a> nhé.
Và tùy vào ngôn ngữ thì chúng ta implement <strong>external service</strong> để gọi API này cho phù hợp.
Nếu thành công, url sẽ được gửi về trong object response.</p>
<h3 id="23-giao-diện-edit-card">2.3 Giao diện edit card</h3>
<p>example url:</p>
<p><a href="https://stg.link.mul-pay.jp/v2/plus/tshop00048001/member/96942eeac78906a6b9edaa9db6724dbd3ad928dbf7ccb18ee855880cb42a269a">https://stg.link.mul-pay.jp/v2/plus/tshop00048001/member/96942eeac78906a6b9edaa9db6724dbd3ad928dbf7ccb18ee855880cb42a269a</a></p>
<p>Chúng ta nhúng url này vào website, khi người dùng request add card thì tiến hành redirect tới url trên và kết quả nhận được như sau:
<img src="https://images.viblo.asia/e4892918-6579-4492-ba73-f5804a35151f.png" alt=""></p>
<h2 id="3-chức-năng-thanh-toán">3. Chức năng thanh toán</h2>
<p><img src="https://images.viblo.asia/52a0dcee-6a83-4950-b65b-c51eece86bd7.png" alt="">
Mô tả luồng hoạt động :</p>
<ol>
<li>Người dùng mua hàng, đi đến màn hình thành toán, chọn thanh toán.</li>
<li>Website chuyển hướng người dùng đến URL thanh toán của GMO.</li>
<li>Người dùng nhập thông tin thanh toán và nhấn xác nhận thanh toán trên site GMO.</li>
<li>GMO gửi thông báo transaction về cho site của shop.</li>
<li>GMO hiển thị màn hình thanh toán thành công cho người dùng.</li>
<li>Người dùng nhấn nút quay về trên site GMO, và được chuyển hướng về website của shop.</li>
</ol>
<p>Cũng giống như luồng chỉnh sửa thẻ (card) thì luồng thanh toán chúng ta cũng chỉ cần tạo được url để chuyển hướng đến màn hình thanh toán của GMO, và cũng có 2 cách để chúng ta có thể có được url này.</p>
<h3 id="31-tạo-url-thanh-toán-theo-định-dạng-mà-gmo-quy-định">3.1 Tạo URL thanh toán theo định dạng mà GMO quy định.</h3>
<p>Format của URL thanh toán :
<img src="https://images.viblo.asia/b36f2478-95e8-451d-aa62-360710db110c.png" alt=""></p>
<ol>
<li>Giao thức https (http không khả dụng)</li>
<li>Domain GMO: Môi trường production: link.mul-pay.jp. Môi trường test: stg.link.mul-pay.jp</li>
<li>Version.</li>
<li>Tên của loại thanh toán Gmo plus.</li>
<li>shopId. (ID cửa hàng của cửa hàng thành viên).</li>
<li>Loại chức năng. Chỉ định &quot;checkout&quot; cho biết chức năng thanh toán.</li>
<li>Bộ tham số được mã hóa base64 + mã băm của nó. ( chi tiết mình sẽ mô tả sau).</li>
</ol>
<p>Các bước để tạo bộ tham số mã hóa base64 và mã băm (7).
<img src="https://images.viblo.asia/4996e807-003e-4b72-be33-bf426c3451ff.png" alt="">
Giống như việc tạo ra url edit card chúng ta có đoạn code example bằng java sau:
{@embed: <a href="https://gist.github.com/tungpv-0974/def5dad58a493d84a0b0024837232490%7D">https://gist.github.com/tungpv-0974/def5dad58a493d84a0b0024837232490}</a></p>
<p>Bộ tham số cho việc thanh toán các bạn có thể đọc mục <strong>4.5.1 trang 40</strong>  <a href="https://drive.google.com/file/d/1gcpTEoKt7-_QWgZPqWI4f30RdkKxCr28/view?usp=sharing">tài liệu này</a> nhé.</p>
<h3 id="32-api-get-url-payment-do-gmo-cung-cấp">3.2 API get URL payment do GMO cung cấp.</h3>
<p>GMO sẽ cung cấp cho chúng ta đầu API sau để get URL payment :  <strong>[POST]https://[gmo-url]/payment/GetLinkplusUrlPayment.json</strong></p>
<p>[gmo-url] là thông tin được gửi về trong email lúc chúng ta đăng ký với GMO, xem thêm bài viết  <a href="https://viblo.asia/p/tim-hieu-ve-cong-thanh-toan-gmo-3P0lPvMpKox">Tìm hiểu về cổng thanh toán GMO</a> của tác giả <a href="https://viblo.asia/u/trantrinh1102">Tran Cong Trinh</a>.</p>
<p>example: <a href="https://kt01.mul-pay.jp/payment/GetLinkplusUrlPayment.json">https://kt01.mul-pay.jp/payment/GetLinkplusUrlPayment.json</a></p>
<p>Khi chúng ta gọi API này thành công, sẽ nhận được một URL có format như sau:</p>
<p><img src="https://images.viblo.asia/81e34a84-dc4f-47b6-868c-030425dfac94.png" alt=""></p>
<p>Chỉ khác với format URL mà chúng ta tự tạo ở phần 3.1 là nó được chỉ định version là v2. và (7) là một API key chứ không còn là bộ tham số được mã hóa base64 + hash nữa.
Mình có một đoạn CURL cho việc lấy url thanh toán bằng hình thức credit card như sau:</p>
<pre><code>curl --location --request POST 'https://kt01.mul-pay.jp/payment/GetLinkplusUrlPayment.json' \
--header 'Content-Type: application/json' \
--data-raw '{
    &quot;configid&quot;: &quot;001&quot;,
    &quot;geturlparam&quot;: {
        &quot;ShopID&quot;: &quot;tshop00001111&quot;,
        &quot;ShopPass&quot;: &quot;shopPass&quot;
    },
    &quot;transaction&quot;: {
        &quot;OrderID&quot;: &quot;0001OR123456&quot;,
        &quot;Amount&quot;: 200,
        &quot;Tax&quot;: 10,
        &quot;PayMethods&quot;: [
            &quot;credit&quot;
        ]
    },
    &quot;credit&quot;: {
        &quot;JobCd&quot;: &quot;CAPTURE&quot;,
        &quot;Method&quot;: &quot;1&quot;,
        &quot;TdFlag&quot;: &quot;1&quot;,
        &quot;Tds2Type&quot;: &quot;1&quot;,
        &quot;MemberID&quot;: &quot;1234567&quot;
    }
}'
</code></pre><p>Các tham số chi tiết các bạn đọc ở mục <strong>4.5.1 trang 40</strong>  <a href="https://drive.google.com/file/d/1gcpTEoKt7-_QWgZPqWI4f30RdkKxCr28/view?usp=sharing">tài liệu này</a> nhé.
Và tùy vào ngôn ngữ thì chúng ta implement <strong>external service</strong> để gọi API này cho phù hợp.
Nếu thành công, url sẽ được gửi về trong object response.</p>
<h3 id="33-giao-diện-thanh-toán">3.3 Giao diện thanh toán</h3>
<p>example url:</p>
<p><a href="https://stg.link.mul-pay.jp/v2/plus/tshop00048001/checkout/542f23990a856230d497fe668ab0eef95020a076e5b30a0b7038b603bba72e96">https://stg.link.mul-pay.jp/v2/plus/tshop00048001/checkout/542f23990a856230d497fe668ab0eef95020a076e5b30a0b7038b603bba72e96</a></p>
<p>Chúng ta nhúng url này vào website, khi người dùng request add card thì tiến hành redirect tới url trên và kết quả nhận được như sau:
<img src="https://images.viblo.asia/346b6c30-4044-4b21-8297-f62324d68d66.png" alt=""></p>
<h2 id="4-kết-luận">4. KẾT LUẬN</h2>
<blockquote>
<p>Vậy, để có thể triển khai loại kết nối Link type của GMO( hay còn gọi là GMO plus) thì mấu chốt chúng ta cần tạo ra hoặc lấy được url để nhúng vào website của shop.
Khi người dùng yêu cầu chỉnh sửa thẻ hay thanh toán thì điều hướng đến url đấy. Những việc còn lại sẽ do phía GMO xử lý, nên thông tin người dùng được xử lý và lưu trữ bên phía GMO mà không qua bất kỳ bên trung gian nào. Nâng cao độ an toàn về giao dịch và thông tin của người dùng. Vì vậy loại hình này đang được sử dụng nhiều và thay thế cho cách làm cũ, tuy nhiên tài liệu tiếng Việt không có.</p>
</blockquote>
<blockquote>
<p>Trong quá trình làm dự án mình có tìm hiểu tài liệu <a href="https://drive.google.com/file/d/1gcpTEoKt7-_QWgZPqWI4f30RdkKxCr28/view?usp=sharing">GMO plus</a> và chia sẻ lại ở bài viết này những gì mình đã làm. Vậy nên không tránh việc có thể thiếu sót. Mong mọi người góp ý để mình hoàn thiện hơn.
Thanks!</p>
</blockquote>
]]></description>
                    
                        
                    
                    
                        
                            
                        
                            
                                
                                    
                                    
                                    
                                        <category domain="https://tungpv98.github.io/tags/thanh-to%C3%A1n-online/">Thanh toán online</category>
                                    
                                
                                    
                                    
                                    
                                        <category domain="https://tungpv98.github.io/tags/gmo-plus/">gmo plus</category>
                                    
                                
                                    
                                    
                                    
                                        <category domain="https://tungpv98.github.io/tags/gmo-payment-gateway/">gmo payment gateway</category>
                                    
                                
                            
                        
                    
                </item>
            
        
            
                <item>
                    <title>Restful API with Java framework Dropwizard ( Đờ rốp wi dớt )</title>
                    <link>https://tungpv98.github.io/posts/restful-api-with-java-framework-dropwizard-do-rop-wi-dot/</link>
                    <guid isPermaLink="true">https://tungpv98.github.io/posts/restful-api-with-java-framework-dropwizard-do-rop-wi-dot/</guid>
                    <pubDate>Fri, 22 Jan 2021 08:24:20 +0700</pubDate>
                    <description><![CDATA[<blockquote>
<p>Dạo gần đây vì nhu cầu của dự án, khách hàng muốn team mình code Java bằng framework Dropwizard. Qua mấy ngày tìm hiểu thì mình có một vài chia sẻ như sau :</p>
</blockquote>
<blockquote>
<p>Dropwizard là gì ?
<a href="https://www.dropwizard.io/">https://www.dropwizard.io/</a></p>
<p>Dropwizard is a Java framework for developing ops-friendly, high-performance, RESTful web services</p>
<p>Là một framework nhỏ gọn giúp chúng ta phát triển API một cách nhanh chóng và tiện lợi. Cùng với hiệu năng cao với các ứng dụng microservice.</p>
</blockquote>
<blockquote>
<p>Và lập trình viên chúng ta bao giờ cũng thế! Khi học một ngôn ngữ hoặc framwork mới, chúng ta sẽ làm một project example với cái chúng ta đang học.Mình cũng vậy, vậy nên hôm nay mình xin trình bày cách tạo một ứng dụng API đơn giản bằng Dropwizard.</p>
<p>Bao gồm tạo mới 1 User, xem danh sách User, xem thông tin một User, cập nhật User, và xóa User.</p>
</blockquote>
<h2 id="1-tạo-project-maven">1. Tạo project maven</h2>
<p>Đầu tiên mình sẽ tiến hành tạo một project maven.
{@embed: <a href="https://gist.github.com/tungpv-0974/f2131b561e290ecd80df40524b8e43e9%7D">https://gist.github.com/tungpv-0974/f2131b561e290ecd80df40524b8e43e9}</a>
Sau đấy mình thêm các dependency cần thiết như <code>dropwizard</code> và <code>lombok</code>:</p>
<p>{@embed: <a href="https://gist.github.com/tungpv-0974/207fbd8d694baa1ae986bd78deddf55b%7D">https://gist.github.com/tungpv-0974/207fbd8d694baa1ae986bd78deddf55b}</a></p>
<h2 id="2-config">2. Config</h2>
<p>Tiến hành tạo class <code>AppConfig</code> extends class <code>Configuration</code> như sau:
{@embed: <a href="https://gist.github.com/tungpv-0974/85e003a49509aca7f40c66efc20e2c5b%7D">https://gist.github.com/tungpv-0974/85e003a49509aca7f40c66efc20e2c5b}</a></p>
<p>Tạo file config.yml để config:
{@embed: <a href="https://gist.github.com/tungpv-0974/eb6ad5a1cf7e2c2ec73eaedb40ae9611%7D">https://gist.github.com/tungpv-0974/eb6ad5a1cf7e2c2ec73eaedb40ae9611}</a></p>
<p>Và cuối cùng, chương trình nào cũng phải có hàm main đúng không ?</p>
<p>Mình tạo class <code>MainApplication</code> chứa hàm <code>main</code> để có thể chạy được server:
{@embed: <a href="https://gist.github.com/tungpv-0974/88ae8149df180e90cb363fd6ba0a3506%7D">https://gist.github.com/tungpv-0974/88ae8149df180e90cb363fd6ba0a3506}</a></p>
<blockquote>
<p>Vậy là đã đủ để mình có thể phát triển RestAPI với dropwizard!</p>
</blockquote>
<h2 id="implement-resource">Implement Resource</h2>
<p>Mình sẽ tạo ra một <code>Model</code> có tên là <code>User</code>: <em>(Mình có sử dụng lombok để không phải viết constructor, setter và getter)</em>
{@embed: <a href="https://gist.github.com/tungpv-0974/56ed24e520a3f5894962d79304b089ec%7D">https://gist.github.com/tungpv-0974/56ed24e520a3f5894962d79304b089ec}</a></p>
<p>Tiếp theo mình tạo <code>UserResource</code>, <em>(Resource ở dropwizard giống như controller trong Spring framework)</em>.</p>
<p>Trong UserResource này mình có đầy đủ 5 phương thức GET, POST, PUT và DELETE, đầy đủ cho một <code>RestfulAPI</code> đơn giản :
{@embed: <a href="https://gist.github.com/tungpv-0974/fbc56f1749420b6afd633147f5537225%7D">https://gist.github.com/tungpv-0974/fbc56f1749420b6afd633147f5537225}</a></p>
<p>Với dropwizard, mình phải tiến hành đăng ký resource mới tạo vào trong hàm run() ở class <code>MainApplication</code> thì mới có thể gọi đến các đầu API mình vừa viết ở trong class <code>resource</code>:</p>
<pre><code>    @Override
    public void run(AppConfig configuration, Environment environment) {
        environment.jersey().register(new UserResource());
    }
</code></pre><blockquote>
<p>Vậy là xong rồi !</p>
</blockquote>
<p><strong>Mình tiến hành test API với các curl sau:</strong>
{@embed: <a href="https://gist.github.com/tungpv-0974/0d1c229aceb8e644e8c606e5143df1df%7D">https://gist.github.com/tungpv-0974/0d1c229aceb8e644e8c606e5143df1df}</a></p>
<p>Mặc dù <code>Dropwizard</code> sinh ra để hỗ trợ để tạo ra các API, nhưng nó cũng hỗ trợ webview nếu chúng ta muốn. Trong bài sau, mình sẽ tiến hành cấu hình <code>Dropwizard</code> với <code>thymeleaf</code> để thêm giao diện cho webapp này!</p>
<blockquote>
<p>MÌNH ĐÃ CẬP NHẬT PHẦN CONFIG để sử dụng thymeleaf với dropwizard ở đây ! <a href="https://viblo.asia/p/dropwizard-view-voi-thymeleaf-template-engine-63vKjv36K2R">https://viblo.asia/p/dropwizard-view-voi-thymeleaf-template-engine-63vKjv36K2R</a></p>
<p>Hẹn gặp lại! 😀😀😀</p>
</blockquote>
<blockquote>
<p>SOURCE CODE MÌNH CÓ ĐỂ TẠI ĐÂY !!! <a href="https://github.com/tungpv-0974/example-dropwizard">https://github.com/tungpv-0974/example-dropwizard</a></p>
</blockquote>
]]></description>
                    
                        
                    
                    
                        
                            
                        
                            
                                
                                    
                                    
                                    
                                        <category domain="https://tungpv98.github.io/tags/dropwizard/">Dropwizard</category>
                                    
                                
                                    
                                    
                                    
                                        <category domain="https://tungpv98.github.io/tags/java/">java</category>
                                    
                                
                                    
                                    
                                    
                                        <category domain="https://tungpv98.github.io/tags/restapi/">restapi</category>
                                    
                                
                            
                        
                    
                </item>
            
        
            
                <item>
                    <title>Optional Java 8</title>
                    <link>https://tungpv98.github.io/posts/optional-java-8/</link>
                    <guid isPermaLink="true">https://tungpv98.github.io/posts/optional-java-8/</guid>
                    <pubDate>Fri, 22 Jan 2021 08:22:52 +0700</pubDate>
                    <description><![CDATA[<blockquote>
<p>Nếu bạn là một lập trình viên Java, thì bạn hẳn đã nghe nói hoặc trải nghiệm về NullPointerExceptions trong các chương trình của mình. NullPointerExceptions là các ngoại lệ được jvm ném ra trong quá trình chạy.  Kiểm tra rỗng trong các chương trình thường bị các lập trình viên bỏ qua gây ra các lỗi nghiêm trọng. Java 8 đã giới thiệu<code> Optional&lt;T&gt;</code> để giúp các nhà phát triển xử lý các giá trị null đúng cách.</p>
</blockquote>
<h1 id="optional-là-gì">Optional là gì?</h1>
<p>Optional là một thùng chứa cho một đối tượng có thể là null.
Hãy xem xét hàm findUserById sau, trả về một đối tượng <code>User</code> từ <code>userId</code> truyền vào.</p>
<pre><code>    User findUserById(String userId) { ... };
</code></pre><p>Nếu <code>userId</code> không có trong cơ sở dữ liệu thì hàm trên trả về null.  Bây giờ, hãy xem xét đoạn mã sau:</p>
<pre><code>    User user = findUserById(&quot;667290&quot;);
    System.out.println(&quot;User's Name = &quot; + user.getName());
</code></pre><p>Một trường hợp để xảy ra <code>NullPointerException</code> phổ biến. Lập trình viên đã quên kiểm tra đối tượng <code>User</code> trước khi gọi hàm <code>user.getName()</code>. Bởi vì <code>userId</code> không có trong csdl nên đoạn mã trên sẽ tạo ra một <code>NullPointerException</code>. Chúng ta có thể dùng <code>Optional</code> để giải quyết rắc rối này:</p>
<pre><code>Optional&lt;User&gt; findUserById(String userId) { ... };
</code></pre><p>Bằng cách trả về <code>Optional&lt;User&gt;</code> từ hàm, chúng ta đã nói rõ với những lời gọi hàm này rằng có thể sẽ không có <code>User</code> nào với <code>userId</code> đã cho. Bây giờ lời gọi hàm này chúng ta phải xử lý như sau :</p>
<pre><code>    Optional&lt;User&gt; optional = findUserById(&quot;667290&quot;);

    optional.ifPresent(user -&gt; {
        System.out.println(&quot;User's name = &quot; + user.getName());    
    })
</code></pre><p>Phương thức <code>ifPresent()</code> sẽ gọi biểu thức <code>lambda</code> nếu <code>User</code> tồn tại, nếu không biểu thức <code>lambda</code> sẽ không được gọi.</p>
<h1 id="tạo-đối-tượng-optional">Tạo đối tượng Optional</h1>
<h2 id="1-tạo-một-optional-rỗng">1. Tạo một <code>Optional</code> rỗng</h2>
<pre><code>Optional&lt;User&gt; user = Optional.empty();
</code></pre><h2 id="2-tạo-một-optional-chứa-giá-trị">2. Tạo một <code>Optional</code> chứa giá trị</h2>
<pre><code>User user = new User(&quot;667290&quot;, &quot;Sun Bear&quot;);
Optional&lt;User&gt; userOptional = Optional.of(user);
</code></pre><p>Nếu đối số được cung cấp cho <code>Optional.of()</code> là <code>null</code>, thì nó sẽ ném ra một <code>NullPointerException</code> ngay lập tức và đối tượng <code>Optional</code> sẽ không được tạo.</p>
<h2 id="3-tạo-một-optional-có-giá-trị-hoặc-rỗng">3. Tạo một <code>Optional</code> có giá trị hoặc rỗng</h2>
<pre><code>Optional&lt;User&gt; userOptional = Optional.ofNullable(user);
</code></pre><p>Nếu đối số được truyền đến <code>Optional.ofNullable()</code>không phải là <code>null</code>, thì nó sẽ trả về một <code>Optional</code> chứa giá trị được chỉ định, nếu không nó sẽ trả về một <code>Optional</code> trống.</p>
<h1 id="kiểm-tra-giá-trị-của-optional">Kiểm tra giá trị của <code>Optional</code></h1>
<h2 id="1-ispresent">1. isPresent()</h2>
<p>Phương thức <code>isPresent ()</code> trả về <code>true</code> nếu Tùy chọn chứa giá trị khác rỗng, nếu không, nó trả về <code>false</code>.</p>
<pre><code>    if(optional.isPresent()) {
        System.out.println(&quot;Value found - &quot; + optional.get());
    } else {
        System.out.println(&quot;Optional is empty&quot;);
    }	
</code></pre><h2 id="2-ifpresent">2. ifPresent()</h2>
<p>Phương thức <code>ifPresent ()</code> cho phép gọi biểu thức <code>lambda</code> bên trong nếu <code>optional</code> có giá trị. Nó không có tác dụng gì nếu <code>Optional</code> trống.</p>
<pre><code>optional.ifPresent(value -&gt; {
    System.out.println(&quot;Value found - &quot; + value);
});
</code></pre><h1 id="một-số-phương-thức-optional-cung-cấp">Một số phương thức <code>Optional</code> cung cấp</h1>
<h2 id="1-get">1. get()</h2>
<p>Phương thức <code>get ()</code> của <code>Optional</code> trả về một giá trị nếu nó tồn tại, nếu không nó sẽ ném <code>NoSuchElementException</code>.</p>
<pre><code>User user = optional.get()
</code></pre><h2 id="2-orelse">2. orElse()</h2>
<p><code>orElse ()</code> trả về giá trị mặc định nếu Optional trống. Hãy xem xét ví dụ sau:</p>
<pre><code>User finalUser = (user != null) ? user : new User(&quot;0&quot;, &quot;Unknown User&quot;);
</code></pre><p>Ta có thể dùng <code>orElse()</code> như sau:</p>
<pre><code>User finalUser = optionalUser.orElse(new User(&quot;0&quot;, &quot;Unknown User&quot;));
</code></pre><h2 id="3-orelseget">3. orElseGet()</h2>
<p>Không giống như <code>orElse ()</code>, trả về giá trị mặc định trực tiếp nếu <code>Optional</code> trống, <code>orElseGet ()</code> cho phép bạn chuyển một hàm mà chúng ta cung cấp được gọi khi <code>Optional</code> trống.  Kết quả của hàm được chúng ta cung cấp trở thành giá trị mặc định của <code>Optional</code>.</p>
<pre><code>User finalUser = optionalUser.orElseGet(() -&gt; {
    return new User(&quot;0&quot;, &quot;Unknown User&quot;);
});
</code></pre><h2 id="4-resourcenotfoundexception">4. ResourceNotFoundException()</h2>
<p>Chúng ta có thể sử dụng <code>orElseThrow () </code>để ném một ngoại lệ nếu <code>Optional</code> trống.  Một trường hợp điển hình trong đó điều này có thể hữu ích là - trả về một ngoại lệ <code>ResourceNotFound() </code>tùy chỉnh từ <code>REST API</code> nếu đối tượng với các tham số yêu cầu được chỉ định không tồn tại.</p>
<pre><code>@GetMapping(&quot;/users/{userId}&quot;)
public User getUser(@PathVariable(&quot;userId&quot;) String userId) {
    return userRepository.findByUserId(userId).orElseThrow(
	    () -&gt; new ResourceNotFoundException(&quot;User not found with userId &quot; + userId);
    );
}
</code></pre><h2 id="5-filter">5. filter()</h2>
<p>Giả sử ta có đối tượng <code>Optional&lt;User&gt;</code>.  Muốn kiểm tra giới tính của user đó và gọi một hàm nếu đó là Male.  Đây là cách giúp chúng ta làm điều đó bằng phương pháp cũ:</p>
<pre><code>if(user != null &amp;&amp; user.getGender().equalsIgnoreCase(&quot;MALE&quot;)) {
    // call a function
}
</code></pre><p>Bây giờ, Sử dụng <code>Optional</code> với <code>filter()</code>:</p>
<pre><code>userOptional.filter(user -&gt; user.getGender().equalsIgnoreCase(&quot;MALE&quot;))
.ifPresent(() -&gt; {
      // call a function
})
</code></pre><h2 id="6-map">6. map()</h2>
<p>Giả sử rằng ta muốn lấy địa chỉ của người dùng nếu địa chỉ đã có sẵn và in địa chỉ đó nếu người dùng đến từ VietNam.<br>
Phương thức <code>getAddress () </code>bên trong lớp <code>User</code>:</p>
<pre><code>Address getAddress() {
    return this.address;
}
</code></pre><p>Đây là cách chúng ta làm truyền thống:</p>
<pre><code>if(user != null) {
    Address address = user.getAddress();
    if(address != null &amp;&amp; address.getCountry().equalsIgnoreCase(&quot;VietNam&quot;)) {
	    System.out.println(&quot;User belongs to VietNam&quot;);
    }
}
</code></pre><p>Sử dụng <code>Optional</code> và <code>map()</code>:</p>
<pre><code>userOptional.map(User::getAddress)
.filter(address -&gt; address.getCountry().equalsIgnoreCase(&quot;VietNam&quot;))
.ifPresent(() -&gt; {
    System.out.println(&quot;User belongs to VietNam&quot;);
});
</code></pre><h1 id="kết-luận">Kết luận</h1>
<blockquote>
<p>Bài viết này mình đã trình bày về <code>Optional</code> trong Java 8 và cách sử dụng nó để chúng ta có thể tránh các <code>NullPointerExceptions</code> trong quá trình chúng ta làm việc với Java. Cảm ơn mọi người!</p>
</blockquote>
]]></description>
                    
                        
                    
                    
                        
                            
                        
                            
                        
                    
                </item>
            
        
            
                <item>
                    <title>Lập Lịch Công Việc Với WHENEVER VÀ DELAYED_JOB Trong Rails</title>
                    <link>https://tungpv98.github.io/posts/lap-lich-cong-viec-voi-whenever-va-delayed-job-trong-rails/</link>
                    <guid isPermaLink="true">https://tungpv98.github.io/posts/lap-lich-cong-viec-voi-whenever-va-delayed-job-trong-rails/</guid>
                    <pubDate>Fri, 22 Jan 2021 08:21:22 +0700</pubDate>
                    <description><![CDATA[<p>Trong bài này tôi sẽ giới thiệu với các bạn hai Ruby Gem được sử dụng khá nhiều trong Rails để lập lịch thực hiện công việc, tạo cronjob và triển khai ứng dụng một cách tự động, đó là Whenever và Delayed_job.</p>
<h1 id="i-whenever">I. Whenever</h1>
<p>Whenever là một Ruby Gem cung cấp cú pháp rõ ràng cho việc viết và triển khai cronjobs.</p>
<p>Whenever được dùng để thực hiện các công việc hàng ngày như backup hệ thống, kiểm tra tài khoản người dùng,… và có thể được tích hợp vào Capistrano để tự động tạo cronjobs khi triển khai ứng dụng lên server.</p>
<p>Bạn có thể tìm hiểu về Whenever tai trang Github <a href="https://github.com/javan/whenever">https://github.com/javan/whenever</a>.</p>
<p>Để cài đặt Whenever ta chạy lệnh</p>
<p><code>$ gem install whenever</code></p>
<p>Để bắt đầu sử dụng Whenever, di chuyển đển thư mục ứng dụng và khởi tạo Whenever</p>
<pre><code>$ cd ~/projects/my-project
$ wheneverize .
</code></pre><p>Lệnh wheneverize . sẽ tạo file <code>config/schedule.rb</code></p>
<p>Đây là một ví dụ của file <code>config/schedule.rb</code></p>
<pre><code># Kiểm tra tài khoản người dùng hàng ngày vào lúc 1 giờ sáng
every 1.day, :at =&gt; &quot;1:00am&quot; do
    rails &quot;system:account_check&quot;
end
# Mỗi ngày chạy sao lưu hệ thống 2 lần, cách nhau 12 tiếng
every 12.hours do
   rails &quot;system:run_backup&quot;
end
</code></pre><p>Để đưa các task này vào crontab, ta chạy lệnh:</p>
<p><code>~/projects/my-project$ whenever --update-crontab my-project</code></p>
<p>Ta có thể sử dụng whenever với Capistrano như sau:</p>
<pre><code>set :application, &quot;my-project&quot;
namespace :deploy do
   desc &quot;Update the crontab file&quot;
   task :update_crontab, :roles =&gt; :app do
      run &quot;cd #{release_path} &amp;&amp; whenever --update-crontab #{application}&quot;
   end
end
after &quot;deploy:create_symlink&quot;, &quot;deploy:update_crontab&quot;
</code></pre><p>Đây là nội dung được tạo ra trong crontab khi triển khai ứng dụng bằng Capistrano (chạy lệnh<code> crontab -l</code> từ terminal để xem)</p>
<pre><code># Begin Whenever generated tasks for: my-project
0 1 * * * /bin/bash -l -c 'cd /var/www/projects/my-project/production/releases/20121219061558 &amp;&amp; RAILS_ENV=production bundle exec rake system:account_check --silent &gt;&gt; /var/www/projects/my-project/production/releases/20121219061558/log/cron_log.txt 2&gt;&amp;1'
0 0,12 * * * /bin/bash -l -c 'cd /var/www/projects/my-project/production/releases/20121219061558 &amp;&amp; RAILS_ENV=production bundle exec rake system:run_backup --silent &gt;&gt; /var/www/projects/my-project/production/releases/20121219061558/log/cron_log.txt 2&gt;&amp;1'
# End Whenever generated tasks for: my-project
</code></pre><h1 id="ii-delayed_job">II. Delayed_job</h1>
<p>Delayed_job là Ruby gem thường được sử dụng để thực các công việc có thời gian chạy lâu hoặc các công việc muốn thực hiện trong tương lai. Các công việc này sẽ được chạy nền và không hiển thị đối với người dùng cuối.</p>
<p>Delayed_job giúp cho ứng dụng chạy mượt mà hơn đối với người dùng cuối do các công việc tiêu tốn thời gian sẽ được thực hiện ngầm. Các công việc này có thể là:</p>
<ul>
<li>Gửi email đến người dùng</li>
<li>Thu nhỏ ảnh được tải lên</li>
<li>Tải nội dung từ một trang thứ 3</li>
<li>Đánh chỉ mục hệ thống</li>
<li>Các phép tính toán đòi hỏi thời gian…</li>
</ul>
<p>Ngoài ra Delayed_job cũng phù hợp với các công việc được thực hiện theo một kế hoạch nào đó, chẳng hạn như định kỳ gửi bản tin đến người dùng.</p>
<p>Ban đầu Delayed_job được viết bởi tác giả Tobias Lütke (<a href="https://github.com/tobi),">https://github.com/tobi),</a> sau đó được fork lại bởi Collective Idea (<a href="https://github.com/collectiveidea">https://github.com/collectiveidea</a>) và hiện tại phiên bản của Collective Idea đang được sử dụng phổ biến hơn.</p>
<p>Bạn có thể tìm hiểu thêm về delayed_job tại địa chỉ <a href="https://github.com/collectiveidea/delayed_job">https://github.com/collectiveidea/delayed_job</a></p>
<p>Dưới đây là các bước cài đặt và sử dụng Delayed_job trong Rails với ActiveRecord.</p>
<p>Để cài đặt Delayed_job cho Active Record, bạn sử dụng <code>gem ‘delayed_job_active_record’</code></p>
<ul>
<li>
<p>Khởi tạo delayed_job</p>
<pre><code>$ rails g delayed_job:active_record
$ rails db:migrate
</code></pre></li>
<li>
<p>Khởi động Worker của Delayed_job</p>
<pre><code>$ rake jobs:work
</code></pre></li>
<li>
<p>Sử dụng Delayed_job theo cách đơn giản, ví dụ gửi email cho người dùng sau khi đăng ký thành công</p>
<ul>
<li>Trước khi sử dụng Delayed_job</li>
</ul>
<pre><code>NotificationMailer.notify_account_activated(@user).deliver
</code></pre></li>
<li>
<p>Với Delayed_job</p>
<pre><code>    NotificationMailer.delay.notify_account_activated(@user)
</code></pre><p>Ta cũng có thể sử dụng Delayed_job để thực hiện công việc theo lịch hay định kỳ. Trong ví dụ này ứng dụng sẽ gửi email đến người dùng vừa kích hoạt sau một ngày, vào lúc 8 giờ sáng.</p>
<pre><code>    RAILS_ROOT/lib/delayed_jobs/newsletter_job.rb
     class NewsletterJob &lt; Struct.new(:user)
       def perform
         NewsletterMailer.welcome_mail(user).deliver
       end
     end

     # Controller
     # run at 8 a.m next day
     Delayed::Job.enqueue NewsletterMailer.new(@user) , 0, 1.day.from_now.change({:hour =&gt; 8 })
</code></pre><p>Sử dụng Delayed_job với Capistrano</p>
</li>
</ul>
<p>Trước tiên bạn cần cài đặt Ruby gem có tên “daemons” để chạy worker của delayed_job như một process của hệ thống.</p>
<pre><code>gem install 'daemons'
</code></pre><pre><code># Location: config/deploy.rb
namespace :delayed_job do
  desc &quot;Start delayed_job process&quot;
  task :start, :roles =&gt; :app do
    run &quot;cd #{current_path}; RAILS_ENV=#{rails_env} script/delayed_job start&quot;
  end

  desc &quot;Stop delayed_job process&quot;
  task :stop, :roles =&gt; :app do
    run &quot;cd #{current_path}; RAILS_ENV=#{rails_env} script/delayed_job stop&quot;
  end

  desc &quot;Restart delayed_job process&quot;
  task :restart, :roles =&gt; :app do
   run &quot;cd #{current_path}; RAILS_ENV=#{rails_env} script/delayed_job restart&quot;
  end
end
</code></pre><p>Như vậy Whenever và Delayed_job sẽ giúp cho bạn thực hiện công việc theo lịch định sẵn, tăng tốc độ ứng dụng đối với người dùng cuối và triển khai lên server một cách nhanh chóng và tự đông.</p>
]]></description>
                    
                        
                    
                    
                        
                            
                        
                            
                        
                    
                </item>
            
        
            
                <item>
                    <title>Export file pdf từ html trong ứng dụng Rails</title>
                    <link>https://tungpv98.github.io/posts/export_file_pdf_from_html_in_rails/</link>
                    <guid isPermaLink="true">https://tungpv98.github.io/posts/export_file_pdf_from_html_in_rails/</guid>
                    <pubDate>Fri, 22 Jan 2021 08:17:31 +0700</pubDate>
                    <description><![CDATA[<p>Pdf là một trong những định dạng phổ biến hiện nay, với ưu điểm là chất lượng cao và không dễ bị thay đổi font chữ hay bố cục của nội dung. Vì thế pdf thường xuyên được sử dụng để lưu trữ những nội dung sau khi đã hoàn thiện và dùng chúng để trao đổi qua mạng. Trong một số website nhiều tác vụ cũng cần đến việc lưu trữ thành định dạng pdf để thuận tiện cho việc lưu trữ lại của người dùng, vì thế hôm nay mình viết bài viết này để tạo một website đơn giản bằng Ruby on Rails có tích hợp tính năng xuất file pdf từ thông tin của trang web với gem PDFKit !!!</p>
<h1 id="tạo-ứng-dụng-rails">Tạo ứng dụng Rails</h1>
<p>Tạo một ứng dụng với tên là invoices (hóa đơn) và thêm 2 models:</p>
<pre><code>$ rails new invoices -d mysql
$ cd invoices
 
$ rails generate model invoice date:date client notes total
$ rails generate model line_item description price:float invoice:references
</code></pre><p>sau đó thêm một số dữ liệu mẫu vào cơ sở dữ liệu bằng cách thêm vào file <code>db/seeds.rb.</code></p>
<pre><code>invoice = Invoice.create(
  client: 'Tùng Phan',
  total: 165000,
  date: Date.new(2020, 2, 17))

LineItem.create([
  { invoice_id: invoice.id, description: 'Tuổi trẻ đáng giá bao nhiêu???', price: 96000 },
  { invoice_id: invoice.id, description: 'Mắt Biếc (Tái Bản 2019)', price: 69000} ])
</code></pre><p>Chạy lệnh rails db:seed trong terminal để thêm hóa đơn mẫu vào cơ sở dữ liệu.</p>
<h3 id="tạo-controller-and-view">Tạo controller and view</h3>
<p>chạy lệnh <code>rails generate controller Invoices index show</code>để tạo controllers và views.</p>
<p><em><strong>app/models/invoice.rb</strong></em></p>
<pre><code>class Invoice &lt; ApplicationRecord
  has_many :line_items
end
</code></pre><p><em><strong>app/models/line_item.rb</strong></em></p>
<pre><code>class LineItem &lt; ApplicationRecord
  belongs_to :invoice
end
</code></pre><p><em><strong>app/controllers/invoicescontroller.rb</strong></em></p>
<pre><code> class InvoicesController &lt; ApplicationController
  def index
    @invoices = Invoice.all
  end
 
  def show
    @invoice = Invoice.find(params[:id])
  end
end
</code></pre><p><em><strong>app/views/invoices/index.html.erb</strong></em></p>
<pre><code>&lt;h1&gt;HÓA ĐƠN&lt;/h1&gt;
&lt;ul&gt;
  &lt;% @invoices.each do |invoice| %&gt;
  &lt;li&gt;
    &lt;%= link_to &quot;#{invoice.id} - #{invoice.client} - #{invoice.date.strftime(&quot;%B %d, %Y&quot;)} &quot;, invoice_path(invoice) %&gt;
  &lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</code></pre><p><em><strong>app/views/invoices/show.html.erb</strong></em></p>
<pre><code>&lt;div class=&quot;invoice&quot;&gt;
  &lt;h1&gt;CHI TIẾT HÓA ĐƠN&lt;/h1&gt;

  &lt;h3&gt;KHÁCH HÀNG: &lt;%= @invoice.client %&gt;&lt;/h3&gt;
  &lt;h3&gt;NGÀY: &lt;%= @invoice.date.strftime(&quot;%B %d, %Y&quot;) %&gt;&lt;/h3&gt;

  &lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;TÊN SÁCH&lt;/th&gt;
          &lt;th&gt;GIÁ&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;% @invoice.line_items.each do |line_item| %&gt;
          &lt;tr&gt;
            &lt;td&gt;&lt;%= line_item.description %&gt;&lt;/td&gt;
            &lt;td&gt;&lt;%= number_to_currency(line_item.price) %&gt;&lt;/td&gt;
          &lt;/tr&gt;
        &lt;% end %&gt;
        &lt;tr class=&quot;total&quot;&gt;
          &lt;td style=&quot;text-align: right&quot;&gt;THÀNH TIỀN: &lt;/td&gt;
          &lt;td&gt;&lt;%= number_to_currency(@invoice.total) %&gt;&lt;/span&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
  &lt;/table&gt;

  &lt;% if @invoice.notes %&gt;
  &lt;div class=&quot;notes&quot;&gt;
    &lt;p&gt;&lt;strong&gt;LƯU Ý:&lt;/strong&gt; &lt;%= @invoice.notes %&gt;&lt;/p&gt;
  &lt;/div&gt;
  &lt;% end %&gt;
&lt;/div&gt;

</code></pre><p><em><strong>app/assets/stylesheets/application.scss</strong></em></p>
<pre><code>.invoice {
  width: 700px;
  max-width: 700px;
  border: 1px solid grey;
  margin: 50px;
  padding: 50px;
 
  h1 {
    text-align: center;
    margin-bottom: 100px;
  }
  .notes {
    margin-top: 100px;
  }
 
  table {
    width: 90%;
    text-align: left;
  }
  th {
    padding-bottom: 15px;
  }
 
  .total td {
    font-size: 20px;
    font-weight: bold;
    padding-top: 25px;
  }
}
</code></pre><p>Sau đó <code>rails s</code> và truy cập vào <code>localhost:3000</code> và vào xem chi tiết hóa đơn</p>
<p><img src="https://images.viblo.asia/a2777314-cc74-4c3a-919d-ef77f04a1cbd.PNG" alt=""></p>
<p>Chi tiết hóa đơn</p>
<p><img src="https://images.viblo.asia/03a6eca3-6e49-4299-84d9-343dc6ac425e.PNG" alt=""></p>
<h1 id="tích-hợp-chức-năng-export-pdf">Tích hợp chức năng export Pdf</h1>
<h3 id="thêm-các-gem-vào-gem-file">Thêm các gem vào gem file</h3>
<pre><code>gem 'pdfkit'
gem 'render_anywhere'
gem 'wkhtmltopdf-binary'
</code></pre><p>Sau đó chạy lệnh <code>bundle install</code> để cài đặt các gem vừa thêm vào</p>
<h3 id="tạo-một-class-invoicepdf-trong-thư-mục-appmodels">Tạo một class InvoicePdf trong thư mục app/models</h3>
<p><em><strong>app/models/Invoice_pdf.rb</strong></em></p>
<pre><code>require &quot;render_anywhere&quot;
 
class InvoicePdf
  include RenderAnywhere
 
  def initialize(invoice)
    @invoice = invoice
  end
 
  def to_pdf
    kit = PDFKit.new(as_html, page_size: 'A4')
    kit.to_file(&quot;#{Rails.root}/public/invoice.pdf&quot;)
  end
 
  def filename
    &quot;Invoice #{invoice.id}.pdf&quot;
  end
 
  private
 
    attr_reader :invoice
 
    def as_html
      render template: &quot;invoices/pdf&quot;, layout: &quot;invoice_pdf&quot;, locals: { invoice: invoice }
    end
end
</code></pre><p><em><strong>app/views/invoices/pdf.html.erb</strong></em></p>
<pre><code>&lt;div class=&quot;invoice&quot;&gt;
  &lt;h1&gt;CHI TIẾT HÓA ĐƠN&lt;/h1&gt;
 
  &lt;h3&gt;To: &lt;%= invoice.client %&gt;&lt;/h3&gt;
  &lt;h3&gt;Date: &lt;%= invoice.date.strftime(&quot;%B %d, %Y&quot;) %&gt;&lt;/h3&gt;
 
  &lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;TÊN SÁCH&lt;/th&gt;
          &lt;th&gt;GIÁ&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;% invoice.line_items.each do |line_item| %&gt;
          &lt;tr&gt;
            &lt;td&gt;&lt;%= line_item.description %&gt;&lt;/td&gt;
            &lt;td&gt;&lt;%= number_to_currency(line_item.price) %&gt;&lt;/td&gt;
          &lt;/tr&gt;
        &lt;% end %&gt;
        &lt;tr class=&quot;total&quot;&gt;
          &lt;td style=&quot;text-align: right&quot;&gt;Total: &lt;/td&gt;
          &lt;td&gt;&lt;%= number_to_currency(invoice.total) %&gt;&lt;/span&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
  &lt;/table&gt;
 
  &lt;% if invoice.notes %&gt;
  &lt;div class=&quot;notes&quot;&gt;
    &lt;p&gt;&lt;strong&gt;LƯU Ý:&lt;/strong&gt; &lt;%= invoice.notes %&gt;&lt;/p&gt;
  &lt;/div&gt;
  &lt;% end %&gt;
&lt;/div&gt;
</code></pre><p><em><strong>app/views/layouts/invoice_pdf.html.erb</strong></em></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Envato Invoices&lt;/title&gt;
  &lt;style&gt;
    &lt;%= Rails.application.assets.find_asset('application.scss').to_s %&gt;
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;%= yield %&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="tạo-downloadscontroller-để-render-hóa-đơn-pdf">Tạo DownloadsController để Render hóa đơn PDF</h3>
<p><code>config/routes.rb</code></p>
<pre><code>Rails.application.routes.draw do
  root to: &quot;invoices#index&quot;
 
  resources :invoices, only: [:index, :show] do
    resource :download, only: [:show]
  end
end
</code></pre><p><em><strong>app/controllers/downloadscontroller.rb</strong></em></p>
<pre><code>class DownloadsController &lt; ApplicationController
 
  def show
    respond_to do |format|
      format.pdf { send_invoice_pdf }
    end
  end
 
  private
 
  def invoice_pdf
    invoice = Invoice.find(params[:invoice_id])
    InvoicePdf.new(invoice)
  end
 
  def send_invoice_pdf
    send_file invoice_pdf.to_pdf,
      filename: invoice_pdf.filename,
      type: &quot;application/pdf&quot;,
      disposition: &quot;inline&quot;
  end
end
</code></pre><p>Thêm link download pdf vào hóa đơn : <code>app/views/invoices/show.html.erb</code></p>
<pre><code>&lt;%= link_to &quot;Download PDF&quot;,
  invoice_download_path(@invoice, format: &quot;pdf&quot;),
  target: &quot;_blank&quot;,
  class: &quot;download&quot; %&gt;
</code></pre><p>Chạy <code>rails s</code> chuyển đến hóa đơn chi tiết, click vào <code>Download PDF</code>một tab mới sẽ hiện file pdf hóa đơn!!!</p>
<h2 id="tài-liệu-tham-khảo">Tài liệu tham khảo</h2>
<p><a href="https://www.pdftron.com/blog/rails/how-to-generate-pdf-with-ruby-on-rails/">https://www.pdftron.com/blog/rails/how-to-generate-pdf-with-ruby-on-rails/</a></p>
<p><a href="https://code.tutsplus.com/tutorials/generating-pdfs-from-html-with-rails--cms-22918">https://code.tutsplus.com/tutorials/generating-pdfs-from-html-with-rails--cms-22918</a></p>
]]></description>
                    
                        
                    
                    
                        
                            
                        
                            
                        
                    
                </item>
            
        
            
                <item>
                    <title>Tích hợp &#34;Mod Security&#34; cho Web Application Server để chống lại SQL Injection và tấn công XSS</title>
                    <link>https://tungpv98.github.io/posts/hello-world/</link>
                    <guid isPermaLink="true">https://tungpv98.github.io/posts/hello-world/</guid>
                    <pubDate>Thu, 21 Jan 2021 14:34:56 +0700</pubDate>
                    <description><![CDATA[<h1 id="giới-thiệu">GIỚI THIỆU</h1>
<ul>
<li><a href="https://en.wikipedia.org/wiki/ModSecurity">Mod Security</a> là một module tường lửa có thể tích hợp với các <a href="https://en.wikipedia.org/wiki/Application_server">Web Application Server</a> (máy chủ ứng dụng web) như Apache, IIS, Nginx cho phép phân tích và ghi nhật ký các luồng dữ liệu HTTP/S.Với sự đóng góp từ dự án <a href="https://www.owasp.org/index.php/Category:OWASP_ModSecurity_Core_Rule_Set_Project">ModSecurity Core Rule Set</a> của tổ chức OWASP đã giúp ModSecurity trở nên mạnh mẽ và linh động hơn trong việc phân tích các hành vi có nguy cơ xâm hại an ninh ứng dụng web.</li>
<li>Mod Security đứng trước Web Server, làm nhiệm vụ như một firewall để kiểm soát truy cập vào ra Web Server. Các thông tin đi từ bên ngoài vào và bên trong ra sẽ được kiểm soát chặt chẽ để tránh những thông tin có thể gây hại cho Web Server hay là việc rò rỉ các thông tin đặc biệt từ Web Server đến Client.</li>
</ul>
<p><img src="https://images.viblo.asia/e5f7886a-8fdd-486b-a2a2-7ed86660645b.png" alt=""></p>
<ul>
<li>Mod Security có thể :</li>
</ul>
<ol>
<li>Request filtering: tất cả các request gửi đến web server đều được phân tích và càn lọc (filter) trước khi chúng được đưa đến các modules khác để xử lý.</li>
<li>Anti-evasion techniques: paths và parameters được chuẩn hóa trước khi phân tích để chống evasion techniques.</li>
<li>Understanding of the HTTP protocol: ModSecurity là web application firewall nên nó có khả năng hiểu được HTTP protocol. ModSecurity có khả năng càn lọc dựa trên các thông tin ở HTTP header hay có thể xem xét đến từng parameters hay cookies của các requests…</li>
<li>POST payload analysis: ngoài việc càn lọc dựa trên HTTP header, ModSecurity có thể dựa trên nội dung (payload) của POST request.</li>
<li>Audit logging: mọi request đều có thể được ghi lại (bao gồm cả POST) để người quản trị có thể theo dõi nếu cần.</li>
<li>HTTPS filtering: ModSecurity có thể phân tích HTTPS.</li>
<li>Compressed content filtering: ModSecurity sẽ phân tích sau khi đã decompress các request data.</li>
</ol>
<ul>
<li>Và trong bài viết này chúng ta sẽ tiến hành tích hợp Mod Security cho Apache Web Server để chống lại SQL Injection và tấn công XSS.</li>
</ul>
<h1 id="1-sql-injection-và-tấn-công-xss-khi-chưa-tích-hợp-mod-security">1. SQL Injection và tấn công XSS khi chưa tích hợp Mod Security</h1>
<p>Để thử nghiệm SQL Injection và tấn công XSS thì mình sử dụng <a href="https://github.com/ethicalhack3r/DVWA">Damn Vulnerable Web Application (DVWA)</a> một ứng dụng mã nguồn PHP tập hợp sẵn các lỗi logic về bảo mật trong đó có SQL Injection và XSS.
Sau khi tải mã nguồn từ : <a href="https://github.com/ethicalhack3r/DVWA,">https://github.com/ethicalhack3r/DVWA,</a> giải nén vào thư mục C:\xampp\htdocs, khởi chạy và đăng nhập bằng tài khoản username/password: admin/password thì giao diện trang web như sau:</p>
<p><img src="https://images.viblo.asia/d0c04ae4-15e6-4285-b5db-91ebf9bdc466.PNG" alt=""></p>
<h2 id="11-thử-nghiệm-sql-injection">1.1 Thử nghiệm SQL Injection</h2>
<p>Vào SQL Injection nhập vào <code>%' or '0'='0</code> và submit</p>
<p><img src="https://images.viblo.asia/81ef4196-8ae0-46c2-babf-98a588be71fa.PNG" alt=""></p>
<p>Kết quả sẽ nhận được thông tin của tất cả các users có trong cơ sở dữ liệu. Bởi vì câu truy vấn lúc này được hiểu là : <code>SELECT * FROM users WHERE user_id = '%' or '0'='0'</code></p>
<h2 id="12-thử-nghiệm-xss">1.2 Thử nghiệm XSS</h2>
<p>Vào XSS stored và submit đoạn script sau: <code>&lt;script&gt;alert(&quot;Hacked! – KMA&quot;)&lt;/script&gt;</code>:</p>
<p><img src="https://images.viblo.asia/48963635-c553-4709-a729-2384159d592c.PNG" alt=""></p>
<p>Sau khi submit đoạn script trên thì mỗi lần truy cập vào, trang web sẽ hiện một thông báo cho người dùng như sau:</p>
<p><img src="https://images.viblo.asia/fd53ef7f-1b77-44f9-8650-8d72b3c4e9fe.PNG" alt=""></p>
<p>Qua một vài thao tác đơn giản có thể thấy được lỗi SQL Injection và XSS rất dễ dàng bị khai thác. Vì vậy cần có phương pháp để chống lại các dạng tấn công này.
Có rất nhiều phương pháp để chống lại tấn công SQL Injection và XSS nhưng trong bài viết này mình chỉ đề cập đến phương pháp tích hợp tường lửa và cụ thể là Mod Security trên Apache.</p>
<h1 id="2-cài-đặt-và-cấu-hình-mod-security">2 Cài đặt và cấu hình Mod Security</h1>
<h2 id="21-cài-đặt">2.1 Cài đặt</h2>
<p><strong>Truy cập vào  <a href="https://www.apachelounge.com/download/">https://www.apachelounge.com/download/</a> và tải về mod_security tương ứng.</strong></p>
<p><img src="https://images.viblo.asia/a1dcd589-50b0-4628-8769-d12d91c0fd37.PNG" alt=""></p>
<p><strong>Giải nén và tìm 2 file <code>mod_security2.so</code> và <code>yajl.dll</code> trong thư mục vừa giải nén.</strong></p>
<ul>
<li>copy <code>mod_security2.so</code> vào <code>...\apache\modules</code></li>
<li>copy <code>yajl.dll</code> vao <code>...\apache\bin</code></li>
</ul>
<p><strong>Mở file <code>httpd.conf</code> của Xampp và thêm vào các dòng sau:</strong></p>
<p><code>LoadModule security2_module modules/mod_security2.so</code></p>
<p><code>SecRuleEngine DetectionOnly</code></p>
<p><code>&lt;IfModule security2_module&gt;</code></p>
<p><code>SecRuleEngine On</code></p>
<p><code>SecDefaultAction &quot;phase:2,deny,log,status:403&quot;</code></p>
<p><code>Include conf/sqlinjection.conf</code></p>
<p><code>Include conf/xss.conf</code></p>
<p><code>&lt;/IfModule&gt;</code></p>
<p><img src="https://images.viblo.asia/500f34af-ef20-4d00-9ba5-165ea0595da6.jpg" alt=""></p>
<h2 id="22-tạo-file-conf-để-thiết-lập-rules">2.2 Tạo file conf để thiết lập rules</h2>
<p><strong>Tiến hành tạo 2 file <code>sqlinjection.conf</code> và <code>xss.conf</code> trong thư mục <code>apache\conf</code> của Xampp.</strong></p>
<p><strong>Clone toàn bộ <a href="https://raw.githubusercontent.com/SEC642/modsec/master/rules/base_rules/modsecurity_crs_41_sql_injection_attacks.conf">rules SQL Injection</a> vào file <code>sqlinjection.conf</code> và <a href="https://github.com/SEC642/modsec/blob/master/rules/base_rules/modsecurity_crs_41_xss_attacks.conf">rules XSS Injection</a> vào file <code>xss.conf</code>.</strong></p>
<p>Tiến hành restart lại Xampp Apache. Thử nghiệm lại tấn công SQL Injection và XSS như ở phần 1. Kết quả như hình:</p>
<p><img src="https://images.viblo.asia/571490c9-7c33-4e9d-89ea-8b5a6d64f179.PNG" alt=""></p>
<p>Và đồng thời file nhật ký ghi nhận được request xấu từ người dùng đã bị chặn lại:</p>
<p><img src="https://images.viblo.asia/3e272a12-b924-48d5-9e2f-f1201ce55c7f.PNG" alt=""></p>
<p>Video demo:</p>
<p>{@embed: <a href="https://www.youtube.com/watch?v=WRb69P-Oe8Y%7D">https://www.youtube.com/watch?v=WRb69P-Oe8Y}</a></p>
<h1 id="kết-luận">Kết luận</h1>
<p>Chỉ một vài bước đơn giản, chúng ta đã có thể chống lại tấn công SQL Injection và XSS mà không cần phải chỉnh sửa lại mã nguồn của trang web. Bằng việc kết hợp Mod Security và các bộ rules do tổ chức OWASP để chống lại nhiều loại tấn công phổ biến vào ứng dụng web. Cũng như có thể viết ra các rules phù hợp với mục đích sử dụng của riêng từng cá nhân và công ty. Chi phí đầu tư thấp, được hỗ trợ rộng rãi bởi cộng đồng bảo mật vì vậy giải pháp sử dụng Mod Security là một lựa chọn rất tốt trong việc bảo mật cho ứng dụng web.</p>
<h3 id="cuối-cùng">Cuối cùng</h3>
<p>Bài viết được viết trên sự hiểu biết có hạn của cá nhân mình, có gì sai sót mong được mọi người góp ý! <strong>Thank all!</strong></p>
<h1 id="tham-khảo">Tham Khảo</h1>
<p><a href="https://en.wikipedia.org/wiki/ModSecurity">https://en.wikipedia.org/wiki/ModSecurity</a></p>
<p><a href="https://keirstenbrager.tech/sql-vs-xxs-injection-attacks-explained/">https://keirstenbrager.tech/sql-vs-xxs-injection-attacks-explained/</a></p>
]]></description>
                    
                        
                    
                    
                        
                            
                        
                            
                        
                    
                </item>
            
        
    </channel>
</rss>